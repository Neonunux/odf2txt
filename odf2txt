#!/bin/env python
#
# odf2txt - Convert ODF documents to text
#
# Copyright 2013 Matthe Woehlke <mw_triad@users.sourceforge.net>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import sys
import xml.sax
import zipfile

recognized_paragraph_properties = {
  'fo:background-color',
  'fo:border',
  'fo:border-bottom',
  'fo:border-left',
  'fo:border-right',
  'fo:border-top',
  'fo:break-before',
  'fo:hyphenation-ladder-count',
  'fo:keep-together',
  'fo:keep-with-next',
  'fo:margin',
  'fo:margin-bottom',
  'fo:margin-left',
  'fo:margin-right',
  'fo:margin-top',
  'fo:orphans',
  'fo:padding',
  'fo:padding-bottom',
  'fo:padding-left',
  'fo:padding-right',
  'fo:padding-top',
  'fo:text-align',
  'fo:text-indent',
  'fo:widows',
  'style:auto-text-indent',
  'style:contextual-spacing',
  'style:font-independent-line-spacing', # NOT DISPLAYED
  'style:justify-single-word',
  'style:line-break',
  'style:page-number',
  'style:punctuation-wrap',
  'style:shadow',
  'style:tab-stop-distance',
  'style:text-autospace', # NOT DISPLAYED
  'style:writing-mode', # NOT DISPLAYED
  'text:line-number',
  'text:number-lines',
}

recognized_text_properties = {
  'fo:background-color',
  'fo:color',
  'fo:country', # NOT DISPLAYED
  'fo:font-size',
  'fo:font-style',
  'fo:font-weight',
  'fo:hyphenate',
  'fo:hyphenation-push-char-count',
  'fo:hyphenation-remain-char-count',
  'fo:language', # NOT DISPLAYED
  'fo:text-shadow',
  'officeooo:paragraph-rsid', # NOT DISPLAYED
  'officeooo:rsid', # NOT DISPLAYED
  'style:font-name',
  'style:font-relief',
  'style:text-underline-color',
  'style:text-underline-style',
  'style:text-underline-width',
  'style:use-window-font-color',
}

recognized_content_tags = {
  'office:forms',
  'office:text',
  'text:h',
  'text:line-break',
  'text:list',
  'text:list-item',
  'text:p',
  'text:s',
  'text:sequence-decl',
  'text:sequence-decls',
  'text:soft-page-break',
  'text:span',
  'text:tab',
}

defined_styles = {}
inline_styles = {}

#------------------------------------------------------------------------------
class context_parser(xml.sax.ContentHandler):
  def __init__(self, root_parser):
    xml.sax.ContentHandler.__init__(self)
    self.root_parser = root_parser

  def beginContext(self, name, attrs):
    pass

  def endContext(self):
    pass

#------------------------------------------------------------------------------
class parse_style_tab_stops(context_parser):
  #----------------------------------------------------------------------------
  def __init__(self, root_parser):
    context_parser.__init__(self, root_parser)
    self.stops = []

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    if name == 'style:tab-stop':
      self.stops.append(attrs)

  #----------------------------------------------------------------------------
  def endContext(self):
    if not len(self.stops):
      return

    text = ''
    for stop in self.stops:
      if len(text):
        text += ', '

      text += stop['style:position']
      if 'style:type' in stop:
        text += ' ' + stop['style:type']

    print '  tab-stops: %s;' % text

#------------------------------------------------------------------------------
def extract_rule(attrs, key, display_name = None):
  if display_name is None:
    display_name = key[key.find(':') + 1:]

  if key in attrs:
    return ['%s: %s;' % (display_name, attrs[key])]
  else:
    return []

#------------------------------------------------------------------------------
def extract_lang_rules(attrs, key, display_name = None):
  rules = []

  if display_name is None:
    display_name = key[key.find(':') + 1:]

  if key in attrs:
    common_value = attrs[key]
    rules += ['%s: %s;' % (display_name, common_value)]

    asian_key = key + '-asian'
    if asian_key in attrs and attrs[asian_key] != common_value:
      rules += ['%s-asian: %s;' % (display_name, attrs[asian_key])]

    complex_key = key + '-complex'
    if complex_key in attrs and attrs[complex_key] != common_value:
      rules += ['%s-complex: %s;' % (display_name, attrs[complex_key])]

  return rules

#------------------------------------------------------------------------------
def extract_edge_rules(attrs, key, display_name = None):
  if display_name is None:
    display_name = key[key.find(':') + 1:]

  return extract_rule(attrs, key, display_name) + \
         extract_rule(attrs, key + '-top', display_name + '-top') + \
         extract_rule(attrs, key + '-left', display_name + '-left') + \
         extract_rule(attrs, key + '-right', display_name + '-right') + \
         extract_rule(attrs, key + '-bottom', display_name + '-bottom')

#------------------------------------------------------------------------------
def extract_style_rules(name, attrs):
  rules = []

  if name == 'style:paragraph-properties':
    rules += extract_rule(attrs, 'fo:background-color')

    rules += extract_edge_rules(attrs, 'fo:border')
    rules += extract_edge_rules(attrs, 'fo:margin')
    rules += extract_edge_rules(attrs, 'fo:padding')
    rules += extract_rule(attrs, 'style:contextual-spacing')

    rules += extract_rule(attrs, 'fo:text-align')
    rules += extract_rule(attrs, 'style:justify-single-word')
    rules += extract_rule(attrs, 'fo:text-indent')
    rules += extract_rule(attrs, 'style:auto-text-indent')
    rules += extract_rule(attrs, 'style:punctuation-wrap')

    rules += extract_rule(attrs, 'fo:hyphenation-ladder-count')

    rules += extract_rule(attrs, 'style:line-break')
    rules += extract_rule(attrs, 'fo:break-before')
    rules += extract_rule(attrs, 'fo:keep-together')
    rules += extract_rule(attrs, 'fo:keep-with-next')
    rules += extract_rule(attrs, 'fo:orphans')
    rules += extract_rule(attrs, 'fo:widows')

    rules += extract_rule(attrs, 'style:tab-stop-distance')
    rules += extract_rule(attrs, 'style:shadow')

    rules += extract_rule(attrs, 'text:number-lines')
    rules += extract_rule(attrs, 'text:line-number')
    rules += extract_rule(attrs, 'style:page-number')

    for attr in attrs.keys():
      #if attr.endswith('-asian') or attr.endswith('-complex'):
      if not attr in recognized_paragraph_properties:
        rules += ['/* unhandled %s attribute \'%s\' */' % (name[6:], attr)]

  elif name == 'style:text-properties':
    rules += extract_rule(attrs, 'fo:background-color')
    rules += extract_rule(attrs, 'fo:color')
    if 'style:use-window-font-color' in attrs:
      print '  font-color: window;'
    rules += extract_lang_rules(attrs, 'style:font-name')
    rules += extract_lang_rules(attrs, 'fo:font-size')
    rules += extract_lang_rules(attrs, 'fo:font-style')
    rules += extract_lang_rules(attrs, 'fo:font-weight')

    if 'style:text-underline-style' in attrs:
      underline_style = attrs['style:text-underline-style']
      if 'style:text-underline-width' in attrs:
        underline_style += ' ' + attrs['style:text-underline-width']
      if 'style:text-underline-color' in attrs:
        underline_style += ' ' + attrs['style:text-underline-color']
      rules += ['text-underline: %s;' % underline_style]

    rules += extract_rule(attrs, 'fo:text-shadow')
    rules += extract_rule(attrs, 'style:font-relief', 'text-relief')

    if 'fo:hyphenate' in attrs:
      text = attrs['fo:hyphenate']
      if 'fo:hyphenation-push-char-count' in attrs:
        text += ' ' + attrs['fo:hyphenation-push-char-count']
      elif 'fo:hyphenation-remain-char-count' in attrs:
        text += ' auto'
      if 'fo:hyphenation-remain-char-count' in attrs:
        text += ' ' + attrs['fo:hyphenation-remain-char-count']
      rules += ['hyphenate: %s;' % text]

    for attr in attrs.keys():
      if attr.endswith('-asian') or attr.endswith('-complex'):
        continue;
      if not attr in recognized_text_properties:
        rules += ['/* unhandled %s attribute \'%s\' */' % (name[6:], attr)]

  else:
    return ['/* unhandled tag \'%s\' */' % name]

  return rules

#------------------------------------------------------------------------------
class parse_style_style(context_parser):
  #----------------------------------------------------------------------------
  def beginContext(self, name, attrs):
    # Only handle named non-default styles
    if name == 'style:style':
      style_name = attrs['style:name']

      # Skip non-user styles (do these come from imported Word documents?)
      if style_name.startswith('WW8Num'):
        self.root_parser.popContext()
        return

      # Get display name
      style_display_name = style_name
      if 'style:display-name' in attrs:
        style_display_name = attrs['style:display-name']

      # Print selector
      if 'style:class' in attrs:
        print '%s:%s."%s" {' % (attrs['style:family'], attrs['style:class'],
                                style_display_name)
      else:
        print '%s."%s" {' % (attrs['style:family'], style_display_name)

      # Add to style names map
      defined_styles[style_name] = style_display_name
      self.in_style = True;

    # Handle default styles
    elif name == 'style:default-style':
      print '%s {' % attrs['style:family']
      self.in_style = True;

    # If an unnamed non-default style, cancel the context
    else:
      self.root_parser.popContext()

  #----------------------------------------------------------------------------
  def endContext(self):
    print '}\n'

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    if name == 'style:tab-stops':
      self.root_parser.setContext(parse_style_tab_stops(self.root_parser))

    else:
      for rule in extract_style_rules(name, attrs):
        print '  ' + rule

#------------------------------------------------------------------------------
class style_parser(xml.sax.ContentHandler):
  #----------------------------------------------------------------------------
  def __init__(self):
    xml.sax.ContentHandler.__init__(self)

    self.context_parsers = []
    self.context_tags = []

    self.current_name = None
    self.current_attrs = {}

  #----------------------------------------------------------------------------
  def setContext(self, context):
    self.context_tags.append(self.current_name)
    self.context_parsers.append(context)
    context.beginContext(self.current_name, self.current_attrs)

  #----------------------------------------------------------------------------
  def popContext(self):
    self.context_parsers.pop()
    self.context_tags.pop()

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    self.current_name = name
    self.current_attrs = attrs

    if len(self.context_parsers):
      self.context_parsers[-1].startElement(name, attrs);

    if name == 'style:style' or name == 'style:default-style':
      self.setContext(parse_style_style(self))

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if len(self.context_tags) and name == self.context_tags[-1]:
      self.context_parsers[-1].endContext()
      self.popContext()

    if len(self.context_parsers):
      self.context_parsers[-1].endElement(name);

#------------------------------------------------------------------------------
class simple_content_parser(xml.sax.ContentHandler):

  #----------------------------------------------------------------------------
  def __init__(self):
    xml.sax.ContentHandler.__init__(self)
    self.indent_level = 0

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    if name == 'text:list':
      self.indent_level += 2
    elif name == 'text:list-item':
      sys.stdout.write('\n%s* ' % (' ' * self.indent_level))

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if name == 'text:p' or name == 'text:h':
      print '\n'
    elif name == 'text:list':
      print '\n'
      self.indent_level -= 2
    elif name == 'text:s':
      sys.stdout.write(' ')
    elif name == 'text:tab':
      sys.stdout.write('\t')
    elif name == 'text:line-break':
      sys.stdout.write('\n%s' % (' ' * self.indent_level))

  #----------------------------------------------------------------------------
  def characters(self, content):
    sys.stdout.write(content.encode('utf-8'))

#------------------------------------------------------------------------------
def print_tag_start(name, attrs):
  text = '<!-- unhandled: <' + name
  for attr in attrs.keys():
    text += ' %s=\"%s\"' % (attr, attrs[attr])
  text += '> -->'
  print text

#------------------------------------------------------------------------------
def print_tag_end(name):
  print '<!-- unhandled: </%s> -->' % name

#------------------------------------------------------------------------------
def make_styled_tag(name, attrs):
  if 'text:style-name' in attrs:
    style_name = attrs['text:style-name']
    if style_name in defined_styles:
      return '<%s class=\"%s\">' % (name, defined_styles[style_name])
    elif style_name in inline_styles:
      return '<%s style=\"%s\">' % (name, inline_styles[style_name])

  return '<%s>' % name

#------------------------------------------------------------------------------
class styled_content_parser(simple_content_parser):
  #----------------------------------------------------------------------------
  def __init__(self):
    simple_content_parser.__init__(self)

    self.in_body = False
    self.in_style = None
    self.end_tags = []

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    end_tag = None

    if name == 'office:body':
      self.in_body = True
      self.reinterpret_next = None

    elif self.in_style is not None:
      rules = extract_style_rules(name, attrs)
      if len(rules):
        old_rules = inline_styles[self.in_style]
        if len(old_rules):
          rules = [old_rules] + rules

        inline_styles[self.in_style] = ' '.join(rules)

    elif self.in_body:
      if self.reinterpret_next is not None:
        end_tag = self.reinterpret_next(name, attrs)
        self.reinterpret_next = None

      elif name == 'text:p' and 'text:style-name' in attrs:
        style_name = attrs['text:style-name']
        if style_name != 'Standard':
          sys.stdout.write(make_styled_tag('p', attrs))
          end_tag = '</p>\n\n'

      elif name == 'text:h':
        tag = 'h%s' % attrs['text:outline-level']
        sys.stdout.write(make_styled_tag(tag, attrs))
        end_tag = '</%s>\n\n' % tag

      elif name == 'text:list':
        print '\n%s%s' % ((' ' * self.indent_level),
                          make_styled_tag('list', attrs))
        self.indent_level += 2

      elif name == 'text:list-item':
        def reinterpret_list_item(name, attrs):
          sys.stdout.write(' ' * self.indent_level)
          sys.stdout.write(make_styled_tag('li', attrs))
          return '</li>\n'

        self.reinterpret_next = reinterpret_list_item

      elif name == 'text:span':
        sys.stdout.write(make_styled_tag('span', attrs))
        end_tag = '</span>'

      elif name not in recognized_content_tags:
        print_tag_start(name, attrs)

    elif name == 'style:style':
      self.in_style = attrs['style:name']
      inline_styles[self.in_style] = ''

    self.end_tags.append(end_tag)

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if self.end_tags[-1] is not None:
      sys.stdout.write(self.end_tags[-1])

    elif name == 'text:p':
      print '\n'

    elif name == 'text:s':
      sys.stdout.write('&nbsp;')

    elif name == 'text:tab':
      sys.stdout.write('\t')

    elif name == 'text:line-break':
      sys.stdout.write('<br/>\n%s' % (' ' * self.indent_level))

    elif name == 'text:list':
      self.indent_level -= 2
      print '\n%s</list>' % (' ' * self.indent_level)

    elif name == 'style:style':
      self.in_style = None

    self.end_tags.pop()

  #----------------------------------------------------------------------------
  def characters(self, content):
    sys.stdout.write(content.encode('utf-8'))

#------------------------------------------------------------------------------
def print_raw(archive, filename):
  data = archive.read(filename)
  print data

#------------------------------------------------------------------------------
def parse_xml(archive, filename, parser):
  data = archive.read(filename)
  xml.sax.parseString(data, parser)

#------------------------------------------------------------------------------
def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('document',
                      help='path to document to convert')
  parser.add_argument('--raw', dest='raw', action='store_const',
                      const=True, default=False,
                      help='print raw XML')
  parser.add_argument('--style', dest='style', action='store_const',
                      const=True, default=False,
                      help='include simplified style markup')

  args = parser.parse_args()
  archive = zipfile.ZipFile(args.document)

  # Are we reading the raw XML?
  if args.raw:
    # Print style (if requested) and content, then exit
    args.style and print_raw(archive, 'styles.xml')
    print_raw(archive, 'content.xml')
    return

  if args.style:
    parse_xml(archive, 'styles.xml', style_parser())
    parse_xml(archive, 'content.xml', styled_content_parser())
  else:
    parse_xml(archive, 'content.xml', simple_content_parser())

#------------------------------------------------------------------------------
if __name__ == '__main__':
  main()
