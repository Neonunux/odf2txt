#!/bin/env python

import argparse
import sys
import xml.sax
import zipfile

recognized_text_properties = {
  'fo:background-color',
  'fo:color',
  'fo:country', # NOT DISPLAYED
  'fo:font-size',
  'fo:font-style',
  'fo:font-weight',
  'fo:hyphenate',
  'fo:hyphenation-push-char-count',
  'fo:hyphenation-remain-char-count',
  'fo:language', # NOT DISPLAYED
  'fo:text-shadow',
  'style:font-name',
  'style:font-relief',
  'style:text-underline-color',
  'style:text-underline-style',
  'style:text-underline-width',
  'style:use-window-font-color',
}

recognized_content_tags = {
  'office:text',
  'office:forms',
  'text:h',
  'text:line-break',
  'text:p',
  'text:s',
  'text:sequence-decls',
  'text:sequence-decl',
  'text:soft-page-break',
  'text:span',
  'text:tab',
}

defined_styles = {}
inline_styles = {}

#------------------------------------------------------------------------------
class context_parser(xml.sax.ContentHandler):
  def __init__(self, root_parser):
    xml.sax.ContentHandler.__init__(self)
    self.root_parser = root_parser

  def beginContext(self, name, attrs):
    pass

  def endContext(self):
    pass

#------------------------------------------------------------------------------
class parse_style_tab_stops(context_parser):
  #----------------------------------------------------------------------------
  def __init__(self, root_parser):
    context_parser.__init__(self, root_parser)
    self.stops = []

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    if name == 'style:tab-stop':
      self.stops.append(attrs)

  #----------------------------------------------------------------------------
  def endContext(self):
    if not len(self.stops):
      return

    text = ''
    for stop in self.stops:
      if len(text):
        text += ', '

      text += stop['style:position']
      if 'style:type' in stop:
        text += ' ' + stop['style:type']

    print '  tab-stops: %s;' % text

#------------------------------------------------------------------------------
def extract_rule(attrs, key, display_name):
  rules = []

  if key in attrs:
    common_value = attrs[key]
    rules += ['%s: %s;' % (display_name, common_value)]

    asian_key = key + '-asian'
    if asian_key in attrs and attrs[asian_key] != common_value:
      rules += ['%s-asian: %s;' % (display_name, attrs[asian_key])]

    complex_key = key + '-complex'
    if complex_key in attrs and attrs[complex_key] != common_value:
      rules += ['%s-complex: %s;' % (display_name, attrs[complex_key])]

  return rules

#------------------------------------------------------------------------------
def extract_style_rules(name, attrs):
  rules = []

  if name == 'style:text-properties':
    rules += extract_rule(attrs, 'fo:background-color', 'background-color')
    rules += extract_rule(attrs, 'fo:color', 'color')
    if 'style:use-window-font-color' in attrs:
      print '  font-color: window;'
    rules += extract_rule(attrs, 'style:font-name', 'font-name')
    rules += extract_rule(attrs, 'fo:font-size', 'font-size')
    rules += extract_rule(attrs, 'fo:font-style', 'font-style')
    rules += extract_rule(attrs, 'fo:font-weight', 'font-weight')

    if 'style:text-underline-style' in attrs:
      underline_style = attrs['style:text-underline-style']
      if 'style:text-underline-width' in attrs:
        underline_style += ' ' + attrs['style:text-underline-width']
      if 'style:text-underline-color' in attrs:
        underline_style += ' ' + attrs['style:text-underline-color']
      rules += ['text-underline: %s;' % underline_style]

    rules += extract_rule(attrs, 'fo:text-shadow', 'text-shadow')
    rules += extract_rule(attrs, 'style:font-relief', 'text-relief')

    if 'fo:hyphenate' in attrs:
      text = attrs['fo:hyphenate']
      if 'fo:hyphenation-push-char-count' in attrs:
        text += ' ' + attrs['fo:hyphenation-push-char-count']
      elif 'fo:hyphenation-remain-char-count' in attrs:
        text += ' auto'
      if 'fo:hyphenation-remain-char-count' in attrs:
        text += ' ' + attrs['fo:hyphenation-remain-char-count']
      rules += ['hyphenate: %s;' % text]

    for attr in attrs.keys():
      if attr.endswith('-asian') or attr.endswith('-complex'):
        continue;
      if not attr in recognized_text_properties:
        rules += ['/* unhandled text-properties attribute \'%s\' */' % attr]

    return rules

  else:
    return ['/* unhandled tag \'%s\' */' % name]

#------------------------------------------------------------------------------
class parse_style_style(context_parser):
  #----------------------------------------------------------------------------
  def beginContext(self, name, attrs):
    # Only handle named non-default styles
    if name == 'style:style':
      style_name = attrs['style:name']

      # Skip non-user styles (do these come from imported Word documents?)
      if style_name.startswith('WW8Num'):
        self.root_parser.popContext()
        return

      # Get display name
      style_display_name = style_name
      if 'style:display-name' in attrs:
        style_display_name = attrs['style:display-name']

      # Print selector
      if 'style:class' in attrs:
        print '%s:%s."%s" {' % (attrs['style:family'], attrs['style:class'],
                                style_display_name)
      else:
        print '%s."%s" {' % (attrs['style:family'], style_display_name)

      # Add to style names map
      defined_styles[style_name] = style_display_name
      self.in_style = True;

    # Handle default styles
    elif name == 'style:default-style':
      print '%s {' % attrs['style:family']
      self.in_style = True;

    # If an unnamed non-default style, cancel the context
    else:
      self.root_parser.popContext()

  #----------------------------------------------------------------------------
  def endContext(self):
    print '}\n'

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    if name == 'style:tab-stops':
      self.root_parser.setContext(parse_style_tab_stops(self.root_parser))

    else:
      for rule in extract_style_rules(name, attrs):
        print '  ' + rule

#------------------------------------------------------------------------------
class style_parser(xml.sax.ContentHandler):
  #----------------------------------------------------------------------------
  def __init__(self):
    xml.sax.ContentHandler.__init__(self)

    self.context_parsers = []
    self.context_tags = []

    self.current_name = None
    self.current_attrs = {}

  #----------------------------------------------------------------------------
  def setContext(self, context):
    self.context_tags.append(self.current_name)
    self.context_parsers.append(context)
    context.beginContext(self.current_name, self.current_attrs)

  #----------------------------------------------------------------------------
  def popContext(self):
    self.context_parsers.pop()
    self.context_tags.pop()

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    self.current_name = name
    self.current_attrs = attrs

    if len(self.context_parsers):
      self.context_parsers[-1].startElement(name, attrs);

    if name == 'style:style' or name == 'style:default-style':
      self.setContext(parse_style_style(self))

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if len(self.context_tags) and name == self.context_tags[-1]:
      self.context_parsers[-1].endContext()
      self.popContext()

    if len(self.context_parsers):
      self.context_parsers[-1].endElement(name);

#------------------------------------------------------------------------------
class simple_content_parser(xml.sax.ContentHandler):

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if name == 'text:p' or name == 'text:h':
      print '\n'
    elif name == 'text:s':
      sys.stdout.write(' ')
    elif name == 'text:tab':
      sys.stdout.write('\t')
    elif name == 'text:line-break':
      print

  #----------------------------------------------------------------------------
  def characters(self, content):
    sys.stdout.write(content.encode('utf-8'))

#------------------------------------------------------------------------------
def print_tag_start(name, attrs):
  text = '<!-- unhandled: <' + name
  for attr in attrs.keys():
    text += ' %s=\"%s\"' % (attr, attrs[attr])
  text += '> -->'
  print text

#------------------------------------------------------------------------------
def print_tag_end(name):
  print '<!-- unhandled: </%s> -->' % name

#------------------------------------------------------------------------------
def make_styled_tag(name, attrs):
  if 'text:style-name' in attrs:
    style_name = attrs['text:style-name']
    if style_name in defined_styles:
      return '<%s class=\"%s\">' % (name, defined_styles[style_name])
    elif style_name in inline_styles:
      return '<%s style=\"%s\">' % (name, inline_styles[style_name])

  return '<%s>' % name

#------------------------------------------------------------------------------
class styled_content_parser(simple_content_parser):
  #----------------------------------------------------------------------------
  def __init__(self):
    xml.sax.ContentHandler.__init__(self)

    self.in_body = False
    self.in_style = None
    self.end_tags = []

  #----------------------------------------------------------------------------
  def startElement(self, name, attrs):
    end_tag = None

    if name == 'office:body':
      self.in_body = True

    elif self.in_style is not None:
      rules = extract_style_rules(name, attrs)
      if len(rules):
        old_rules = inline_styles[self.in_style]
        if len(old_rules):
          rules = [old_rules] + rules

        inline_styles[self.in_style] = ' '.join(rules)

    elif self.in_body:
      self.end_tags.append(end_tag)

      if name == 'text:h':
        tag = 'h%s' % attrs['text:outline-level']
        sys.stdout.write(make_styled_tag(tag, attrs))
        end_tag = '</%s>\n\n' % tag

      elif name == 'text:span':
        sys.stdout.write(make_styled_tag('span', attrs))
        end_tag = '</span>'

      elif name not in recognized_content_tags:
        print_tag_start(name, attrs)

    elif name == 'style:style':
      self.in_style = attrs['style:name']
      inline_styles[self.in_style] = ''

    self.end_tags.append(end_tag)

  #----------------------------------------------------------------------------
  def endElement(self, name):
    if self.end_tags[-1] is not None:
      sys.stdout.write(self.end_tags[-1])
    elif name == 'text:p':
      print '\n'
    elif name == 'text:s':
      sys.stdout.write('&nbsp;')
    elif name == 'text:tab':
      sys.stdout.write('\t')
    elif name == 'text:line-break':
      print '<br/>'
    elif name == 'style:style':
      self.in_style = None

    self.end_tags.pop()

  #----------------------------------------------------------------------------
  def characters(self, content):
    sys.stdout.write(content.encode('utf-8'))

#------------------------------------------------------------------------------
def print_raw(archive, filename):
  data = archive.read(filename)
  print data

#------------------------------------------------------------------------------
def parse_xml(archive, filename, parser):
  data = archive.read(filename)
  xml.sax.parseString(data, parser)

#------------------------------------------------------------------------------
def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('document',
                      help='path to document to convert')
  parser.add_argument('--raw', dest='raw', action='store_const',
                      const=True, default=False,
                      help='print raw XML')
  parser.add_argument('--style', dest='style', action='store_const',
                      const=True, default=False,
                      help='include simplified style markup')

  args = parser.parse_args()
  archive = zipfile.ZipFile(args.document)

  # Are we reading the raw XML?
  if args.raw:
    # Print style (if requested) and content, then exit
    args.style and print_raw(archive, 'styles.xml')
    print_raw(archive, 'content.xml')
    return

  if args.style:
    parse_xml(archive, 'styles.xml', style_parser())
    parse_xml(archive, 'content.xml', styled_content_parser())
  else:
    parse_xml(archive, 'content.xml', simple_content_parser())

#------------------------------------------------------------------------------
if __name__ == '__main__':
  main()
